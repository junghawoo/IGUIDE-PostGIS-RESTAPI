apiVersion: batch/v1
kind: Job
metadata:
  name: geodata-import-largest
  labels:
    app.kubernetes.io/name: geodata-import-largest
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "5"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  backoffLimit: {{ .Values.importer.backoffLimit | default 0 }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: geodata-import-largest
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: Never

      # ---- MOUNT THE EXISTING PVC WITH YOUR DATA ----
      volumes:
      - name: import-data
        persistentVolumeClaim:
          claimName: {{ .Values.geodata.existingClaim | quote }}

      containers:
      - name: importer
        image: {{ .Values.importer.image | quote }}
        imagePullPolicy: IfNotPresent
        resources: {{- toYaml .Values.importer.resources | nindent 10 }}
        envFrom:
        - secretRef:
            name: pg-secret
        - configMapRef:
            name: pg-config

        volumeMounts:
        - name: import-data
          mountPath: /data

        command: ["/bin/bash","-lc"]
        args:
        - |
          set -Eeuo pipefail
          trap 'echo "FAILED at line $LINENO"' ERR
          export DEBIAN_FRONTEND=noninteractive

          echo "== Sanity: data directory =="
          ls -la /data || true
          ls -la "$(dirname '{{ .Values.importer.gdbPath }}')" || true
          ls -la "{{ .Values.importer.gdbPath }}" || true

          echo "== Wait for postgres socket =="
          for i in {1..240}; do
            if pg_isready -h postgres -p 5432 >/dev/null 2>&1; then
              echo "Postgres socket ready"
              break
            fi
            echo "Waiting for postgres (socket)..."
            sleep 2
          done

          echo "== Install clients =="
          apt-get update -y
          apt-get install -y --no-install-recommends postgresql-client gdal-bin ca-certificates
          rm -rf /var/lib/apt/lists/*

          export PGPASSWORD="${POSTGRES_PASSWORD}"
          PSQL_SYS="psql -h postgres -U ${POSTGRES_USER} -d postgres -v ON_ERROR_STOP=1"
          PSQL="psql -h postgres -U ${POSTGRES_USER} -d ${POSTGRES_DB} -v ON_ERROR_STOP=1"
          OGR_PG="PG:host=postgres dbname=${POSTGRES_DB} user=${POSTGRES_USER} password=${POSTGRES_PASSWORD}"
          GDB="{{ .Values.importer.gdbPath }}"

          echo "== Ensure target DB exists =="
          $PSQL_SYS <<'SQL'
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = current_setting('app.dbname', true)) THEN
              EXECUTE format('CREATE DATABASE %I', current_setting('app.dbname', true));
            END IF;
          END$$;
          SQL

          # Rebind app.dbname just for above DO block (pg requires)
          $PSQL_SYS -c "SELECT set_config('app.dbname', '${POSTGRES_DB}', false)"

          echo "== Extensions & schema =="
          $PSQL -c "CREATE EXTENSION IF NOT EXISTS postgis;"
          $PSQL -c "CREATE SCHEMA IF NOT EXISTS gis;"

          echo "== Import core layers via GDAL =="
          # Raw inundation polygons and NID points
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Utah_Dam_Inundation_Zones" \
            -nln gis.inundation_zones_raw \
            -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom \
            -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress

          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "UtahDamInundationZones_NID_Dataset" \
            -nln gis.dams_nid \
            -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom \
            -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress

          echo "== Build normalized views (zones & largest) =="
          $PSQL -c "DROP VIEW IF EXISTS gis.inundation_zones CASCADE;"
          $PSQL -c "
            CREATE VIEW gis.inundation_zones AS
            SELECT objectid, damnumber, dam_name, geom
            FROM gis.inundation_zones_raw;
          "

          $PSQL -c "
            CREATE OR REPLACE VIEW gis.inundation_zones_largest AS
            SELECT objectid, damnumber, dam_name, geom
            FROM (
              SELECT objectid, damnumber, dam_name, geom,
                     ROW_NUMBER() OVER (
                       PARTITION BY damnumber
                       ORDER BY ST_Area(geom::geography) DESC
                     ) AS rn
              FROM gis.inundation_zones_raw
            ) s
            WHERE rn = 1;
          "

          echo "== Import vulnerability/infra layers =="
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Utah_Census_Tracts_SVI"      -nln gis.svi_tracts     -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Aviation_Facilities"         -nln gis.aviation       -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "GAP_Status_1and2"            -nln gis.gap_status     -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Hazardous_Waste"             -nln gis.hazardous_waste -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Hospitals"                   -nln gis.hospitals      -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Natural_Gas_Pipelines"       -nln gis.ng_pipelines   -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Power_Plants"                -nln gis.power_plants   -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Railroads"                   -nln gis.railroads      -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Transportation"              -nln gis.transportation -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress
          ogr2ogr -f PostgreSQL "$OGR_PG" "$GDB" "Wastewater_Treatment_Plants" -nln gis.wwtp           -overwrite -t_srs EPSG:4326 -lco GEOMETRY_NAME=geom -nlt CONVERT_TO_LINEAR -nlt PROMOTE_TO_MULTI -dim XY -progress

          echo "== Indexes on layers =="
          $PSQL -c "CREATE INDEX IF NOT EXISTS inundation_zones_raw_geom_gix      ON gis.inundation_zones_raw USING GIST (geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS inundation_zones_raw_damnumber_idx ON gis.inundation_zones_raw (damnumber);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS dams_nid_geom_gix                   ON gis.dams_nid USING GIST (geom);"

          $PSQL -c "CREATE INDEX IF NOT EXISTS svi_tracts_geom_gix       ON gis.svi_tracts USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS aviation_geom_gix         ON gis.aviation USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS gap_status_geom_gix       ON gis.gap_status USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS hazardous_waste_geom_gix  ON gis.hazardous_waste USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS hospitals_geom_gix        ON gis.hospitals USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS ng_pipelines_geom_gix     ON gis.ng_pipelines USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS power_plants_geom_gix     ON gis.power_plants USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS railroads_geom_gix        ON gis.railroads USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS transportation_geom_gix   ON gis.transportation USING GIST(geom);"
          $PSQL -c "CREATE INDEX IF NOT EXISTS wwtp_geom_gix             ON gis.wwtp USING GIST(geom);"

          $PSQL -c "ANALYZE;"

          echo "== Precompute cache table (schema + fill) =="
          $PSQL <<'SQL'
          -- Ensure table and columns expected by the API
          CREATE TABLE IF NOT EXISTS gis.risk_metrics_cache(
            damnumber text PRIMARY KEY,
            dam_name text,
            aviation_count int,
            hazardous_waste_count int,
            hospitals_count int,
            power_plants_count int,
            wwtp_count int,
            ng_pipelines_length_m double precision,
            railroads_length_m double precision,
            transportation_length_m double precision,
            gap_status_area_m2 double precision,
            svi_tracts_area_m2 double precision
          );

          -- Backfill any missing columns without errors on next runs
          DO $$
          DECLARE
            col RECORD;
          BEGIN
            FOR col IN
              SELECT * FROM (VALUES
                ('dam_name','text'),
                ('aviation_count','int'),
                ('hazardous_waste_count','int'),
                ('hospitals_count','int'),
                ('power_plants_count','int'),
                ('wwtp_count','int'),
                ('ng_pipelines_length_m','double precision'),
                ('railroads_length_m','double precision'),
                ('transportation_length_m','double precision'),
                ('gap_status_area_m2','double precision'),
                ('svi_tracts_area_m2','double precision')
              ) AS t(col text, typ text)
            LOOP
              IF NOT EXISTS (
                SELECT 1 FROM information_schema.columns
                WHERE table_schema='gis' AND table_name='risk_metrics_cache' AND column_name=col.col
              ) THEN
                EXECUTE format('ALTER TABLE gis.risk_metrics_cache ADD COLUMN %I %s', col.col, col.typ);
              END IF;
            END LOOP;
          END$$;

          TRUNCATE gis.risk_metrics_cache;

          INSERT INTO gis.risk_metrics_cache(
            damnumber, dam_name,
            aviation_count, hazardous_waste_count, hospitals_count, power_plants_count, wwtp_count,
            ng_pipelines_length_m, railroads_length_m, transportation_length_m,
            gap_status_area_m2, svi_tracts_area_m2
          )
          SELECT
            z.damnumber,
            z.dam_name,
            COALESCE(a.ct,0)   AS aviation_count,
            COALESCE(hw.ct,0)  AS hazardous_waste_count,
            COALESCE(h.ct,0)   AS hospitals_count,
            COALESCE(pp.ct,0)  AS power_plants_count,
            COALESCE(ww.ct,0)  AS wwtp_count,
            COALESCE(ng.len,0) AS ng_pipelines_length_m,
            COALESCE(rr.len,0) AS railroads_length_m,
            COALESCE(tr.len,0) AS transportation_length_m,
            COALESCE(gap.ar,0) AS gap_status_area_m2,
            COALESCE(svi.ar,0) AS svi_tracts_area_m2
          FROM gis.inundation_zones_largest z
          -- counts
          LEFT JOIN LATERAL (
            SELECT COUNT(*) ct FROM gis.aviation t WHERE ST_Intersects(t.geom, z.geom)
          ) a ON TRUE
          LEFT JOIN LATERAL (
            SELECT COUNT(*) ct FROM gis.hazardous_waste t WHERE ST_Intersects(t.geom, z.geom)
          ) hw ON TRUE
          LEFT JOIN LATERAL (
            SELECT COUNT(*) ct FROM gis.hospitals t WHERE ST_Intersects(t.geom, z.geom)
          ) h ON TRUE
          LEFT JOIN LATERAL (
            SELECT COUNT(*) ct FROM gis.power_plants t WHERE ST_Intersects(t.geom, z.geom)
          ) pp ON TRUE
          LEFT JOIN LATERAL (
            SELECT COUNT(*) ct FROM gis.wwtp t WHERE ST_Intersects(t.geom, z.geom)
          ) ww ON TRUE
          -- lengths (m)
          LEFT JOIN LATERAL (
            SELECT COALESCE(SUM(ST_Length(ST_Intersection(t.geom, z.geom)::geography)),0)::double precision AS len
            FROM gis.ng_pipelines t WHERE ST_Intersects(t.geom, z.geom)
          ) ng ON TRUE
          LEFT JOIN LATERAL (
            SELECT COALESCE(SUM(ST_Length(ST_Intersection(t.geom, z.geom)::geography)),0)::double precision AS len
            FROM gis.railroads t WHERE ST_Intersects(t.geom, z.geom)
          ) rr ON TRUE
          LEFT JOIN LATERAL (
            SELECT COALESCE(SUM(ST_Length(ST_Intersection(t.geom, z.geom)::geography)),0)::double precision AS len
            FROM gis.transportation t WHERE ST_Intersects(t.geom, z.geom)
          ) tr ON TRUE
          -- areas (mÂ²)
          LEFT JOIN LATERAL (
            SELECT COALESCE(SUM(ST_Area(ST_Intersection(t.geom, z.geom)::geography)),0)::double precision AS ar
            FROM gis.gap_status t WHERE ST_Intersects(t.geom, z.geom)
          ) gap ON TRUE
          LEFT JOIN LATERAL (
            SELECT COALESCE(SUM(ST_Area(ST_Intersection(t.geom, z.geom)::geography)),0)::double precision AS ar
            FROM gis.svi_tracts t WHERE ST_Intersects(t.geom, z.geom)
          ) svi ON TRUE
          ;

          CREATE INDEX IF NOT EXISTS risk_metrics_cache_damnumber_idx ON gis.risk_metrics_cache(damnumber);
          ANALYZE gis.risk_metrics_cache;
          SQL

          echo "== Import job completed =="

